import numpy as np


# A = np.array([[2, 3, 1],
#               [-1, 1, 0],
#               [1, 2, -1]])

# B = np.array([[1, 2, 1],
#               [0, 1, 2],
#               [3, 1, 1]])

# AB = np.dot(A, B)

# BA = np.dot(B, A)

# C = AB - BA

# print("Матрица C:")
# print(C)



# A = np.array([[-1, 0, 2],
#               [0, 1, 0],
#               [1, 2, -1]])

# A_squared = np.dot(A, A)

# print("Матрица A во второй степени:")
# print(A_squared)



# A = np.array([[5, 8, -4],
#               [6, 9, -5],
#               [4, 7, -3]])

# B = np.array([[3, 2, 5],
#               [4, -1, 3],
#               [9, 6, 5]])

# C = np.dot(A, B)

# print("Результат произведения матриц A и B:")
# print(C)


# A = [[1, 2, 3],
#      [-1, 2, 1],
#      [1, 3, 2]]


# determinant = (A[0][0] * A[1][1] * A[2][2] +
#               A[0][1] * A[1][2] * A[2][0] +
#               A[0][2] * A[1][0] * A[2][1] -
#               A[2][0] * A[1][1] * A[0][2] -
#               A[2][1] * A[1][2] * A[0][0] -
#               A[2][2] * A[1][0] * A[0][1])

# print("Определитель матрицы A:", determinant)

# A = [[2, 3, 4, 1],
#      [1, 2, 3, 4],
#      [3, 4, 1, 2],
#      [4, 1, 2, 3]]


# determinant = (A[0][0] * A[1][1] * A[2][2] * A[3][3] +
#               A[0][0] * A[1][2] * A[2][3] * A[3][1] +
#               A[0][0] * A[1][3] * A[2][1] * A[3][2] +
#               A[0][1] * A[1][0] * A[2][3] * A[3][2] +
#               A[0][1] * A[1][2] * A[2][0] * A[3][3] +
#               A[0][1] * A[1][3] * A[2][2] * A[3][0] +
#               A[0][2] * A[1][0] * A[2][1] * A[3][3] +
#               A[0][2] * A[1][1] * A[2][3] * A[3][0] +
#               A[0][2] * A[1][3] * A[2][0] * A[3][1] +
#               A[0][3] * A[1][0] * A[2][2] * A[3][1] +
#               A[0][3] * A[1][1] * A[2][0] * A[3][2] +
#               A[0][3] * A[1][2] * A[2][1] * A[3][0] -
#               A[0][0] * A[1][1] * A[2][3] * A[3][2] -
#               A[0][0] * A[1][2] * A[2][1] * A[3][3] -
#               A[0][0] * A[1][3] * A[2][2] * A[3][1] -
#               A[0][1] * A[1][0] * A[2][2] * A[3][3] -
#               A[0][1] * A[1][2] * A[2][3] * A[3][0] -
#               A[0][1] * A[1][3] * A[2][0] * A[3][2] -
#               A[0][2] * A[1][0] * A[2][3] * A[3][1] -
#               A[0][2] * A[1][1] * A[2][0] * A[3][3] -
#               A[0][2] * A[1][3] * A[2][1] * A[3][0] -
#               A[0][3] * A[1][0] * A[2][1] * A[3][2] -
#               A[0][3] * A[1][1] * A[2][2] * A[3][0] -
#               A[0][3] * A[1][2] * A[2][0] * A[3][1])

# print("Определитель матрицы A:", determinant)


# A = np.array([[1, 2, 2],
#               [2, 1, -2],
#               [2, -2, 1]])

# try:
#     A_inverse = np.linalg.inv(A)
#     print("Обратная матрица A:")
#     print(A_inverse)
# except np.linalg.LinAlgError:
#     print("Матрица A вырожденная, обратной матрицы не существует.")


# A = np.array([[-2, 3, 1, -1],
#               [3, 2, 1, 4],
#               [1, 2, 3, 4],
#               [0, 2, 3, 3]])

# row_echelon_form, _ = np.linalg.qr(A)

# rank = np.linalg.matrix_rank(row_echelon_form)

# print("Ранг матрицы A:", rank)


# A = np.array([[2, -1, 1],
#               [3, 2, 2],
#               [1, -2, 1]])

# b = np.array([2, -2, 1])

# A_inv = np.linalg.inv(A)

# x = np.dot(A_inv, b)

# print("Решение x = ", x)

# x_check = np.linalg.solve(A, b)
# print("Проверка с помощью solve:", x_check)


N = 4  
M = 3  

matrix = np.random.randint(-10, 10, size=(N, M))

print("Матрица:")
print(matrix)

negatives_in_columns = np.sum(matrix < 0, axis=0)

negatives_in_rows = np.sum(matrix < 0, axis=1)

print("Отрицательных элементов в каждом столбце:", negatives_in_columns)
print("Отрицательных элементов в каждой строке:", negatives_in_rows)
